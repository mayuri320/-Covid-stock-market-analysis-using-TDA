# -*- coding: utf-8 -*-
"""Covid stock market analysis using TDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oGug_Bx1rmB67IijPdycwx_ZmTmSdSrc
"""

!pip install -U giotto-tda

import pandas as pd
import numpy as np
import math
import gtda.time_series as ts
import gtda.diagrams as diag
import gtda.homology as hl
from gtda.plotting import plot_heatmap # gtda plotting functions
import matplotlib.pyplot as plt
import seaborn as sns

# merging two csv files
SP500 = pd.concat(
    map(pd.read_csv, ['2018.csv', '2019.csv', '2020.csv', '2021.csv', '2022.csv']), ignore_index=True)
print(SP500)

"""#Loading and transforming data"""

start_date = '01-Jan-2018'
end_date = '30-Mar-2022'

# merging two csv files
sp500 = pd.concat(
    map(pd.read_csv, ['2018.csv', '2019.csv', '2020.csv', '2021.csv', '2022.csv']), ignore_index=True)
sp500 = sp500[(sp500['Date'] > start_date) & (sp500['Date'] <= end_date) ].reset_index(drop=True)
sp500['Date'] = sp500['Date'].apply(pd.Timestamp)
sp500.set_index('Date', inplace=True)
sp500

dates = sp500.index
dates

plt.figure(figsize=(10,5))
plt.plot(dates, sp500['Close'])
plt.xticks(rotation=70)
plt.title('SP500 prices near COVID-19 days')
plt.show()

"""##Getting log-returns"""

sp500_log = np.zeros(len(sp500))
sp500_log[0] = 0
for i in range(1, len(sp500)):
  sp500_log[i] = math.log(sp500['Close'][dates[i]]/sp500['Close'][dates[i-1]])

sp500['Log-return'] = pd.Series(sp500_log, index=dates)
sp500.drop(dates[0], axis=0, inplace = True)
dates = sp500.index
sp500

plt.figure(figsize=(10,5))
sns.lineplot(x='Date', y='Log-return', data=sp500)
plt.xticks(rotation=70)
plt.title('SP500 log-returns near COVID-19 days')
plt.show()

"""#Methodology

##Time delay embedding
"""

embedding_dimension = 3
embedding_time_delay = 2

embedder = ts.SingleTakensEmbedding(
    parameters_type="fixed",
    dimension=embedding_dimension,
    time_delay=embedding_time_delay,
    n_jobs=-1,
)

log_returns_embedded = embedder.fit_transform(sp500['Log-return'].values)

print(log_returns_embedded.shape)
print(len(sp500))

log_returns_embedded[0]

sp500['Log-return'].head(20)

"""##Rolling window"""

window_size = 60
window_stride = 1

sliding_window = ts.SlidingWindow(size=window_size, stride=window_stride)

log_returns_embedded_windows = sliding_window.fit_transform(log_returns_embedded)

print(f'Number of windows: {log_returns_embedded_windows.shape[0]}')
print(f'Window size: {log_returns_embedded_windows.shape[1]}')
print(f'Embedding dimension: {log_returns_embedded_windows.shape[2]}')
log_returns_embedded_windows.shape

"""Getting windows of prices"""

window_size_price = window_size + (embedding_dimension-1)* embedding_time_delay
sliding_window_price = ts.SlidingWindow(size=window_size_price, stride=window_stride)
price_windows = sliding_window_price.fit_transform(sp500['Close'])
# define time index to combine with numpy arrays
window_indices = sliding_window_price.slice_windows(sp500['Close'])
indices = [win[1]-1 for win in window_indices]
time_index = sp500.iloc[indices].index

print(f'Number of windows: {price_windows.shape[0]}')
print(f'Window size: {price_windows.shape[1]}')
price_windows.shape

print(f'Each window is represented by dates: {time_index.shape}')

i = 0
print(time_index[i])
print(sp500['Close'][time_index[i]])
print(sp500['Log-return'][time_index[i]])
print(log_returns_embedded_windows[i][-1][-1])

"""##Persistence Diagram and Persistence Landscapes"""

homology_dimensions = (0, 1) # homology dimensions of interest
VR = hl.VietorisRipsPersistence(homology_dimensions=homology_dimensions, n_jobs=-1) # Vietoris Rips persistence diagrams
diagrams = VR.fit_transform(log_returns_embedded_windows)

p_landscape = diag.PersistenceLandscape(n_layers=4, n_jobs=-1, n_bins=500)
landscapes = p_landscape.fit_transform(diagrams)

i = log_returns_embedded_windows.shape[0]-20
time_index[i]

p_landscape.plot(landscapes, sample=i)

print(diagrams.shape)
print(landscapes.shape)
print(len(time_index))

"""###Distance between persistence landscapes"""

p = 2
n_layers = 4
PD = diag.PairwiseDistance(metric='landscape',
                      metric_params={'p': p, 'n_layers': n_layers, 'n_bins': 1000},
                      order=None, n_jobs=-1)

distance_L = PD.fit_transform(diagrams)
distance_L.shape

plot_heatmap(distance_L[:, :, 0], colorscale='blues', title="Distances between persistance landscapes of 0-dimensional persistence diagrams")

plot_heatmap(distance_L[:, :, 1], colorscale='blues', title="Distances between persistance landscapes of 1-dimensional persistence diagrams")

"""###Analysis of distances"""

time_index

distance_L.shape

dates[(window_size+(embedding_dimension-1)*embedding_time_delay-1)]

"""###Creation of Turbulence Index (PHTI)"""

outer_window = 60

phti0 = []
phti1 = []
times = []

for j, time in enumerate(time_index[outer_window:]):

  phti0.append(distance_L[j, j+outer_window, 0])
  phti1.append(distance_L[j, j+outer_window, 1])

  times.append(time) 

phti0 = np.array(phti0)
phti1 = np.array(phti1)

phti0 = []
phti1 = []
times = []

for j, time in enumerate(time_index[outer_window:]):

  phti0.append(distance_L[j, j+outer_window, 0])
  phti1.append(distance_L[j, j+outer_window, 1])

  times.append(time) 

phti0 = np.array(phti0)
phti1 = np.array(phti1)

# using outer_window of 60
plt.figure(figsize=(20,6))

plt.subplot(1,2,1)
plt.plot(times, phti0)
plt.axvline(x=times[143], linewidth=2, color='#ff7f0e', linestyle='--')
plt.axvline(x=times[161], linewidth=2, color='red', linestyle='--')
plt.axvline(x=times[167], linewidth=2, color='#ff7f0e', linestyle='--')
plt.tick_params(axis='x', rotation=70)
plt.title("Index based on homology dimension 0")

plt.subplot(1,2,2)
plt.plot(times, sp500['Close'][times])
plt.axvline(x=times[143], linewidth=2, color='#ff7f0e', linestyle='--')
plt.axvline(x=times[161], linewidth=2, color='red', linestyle='--')
plt.axvline(x=times[167], linewidth=2, color='#ff7f0e', linestyle='--')
plt.tick_params(axis='x', rotation=70)
plt.title("Close prices of the SP500")

plt.savefig("SP500")

len(times)

plt.figure(figsize=(10,8))
plt.plot(times, phti1)
#plt.axvline(x=times[216], linewidth=2, color='#ff7f0e', linestyle='--')
#plt.tick_params(axis='x', rotation=70)
#plt.title("Index based on homology dimension 1")

outer_window = 5

phti0 = []
phti1 = []
times = []

for j, time in enumerate(time_index[outer_window:]):

  phti0.append(distance_L[j, j+outer_window, 0])
  phti1.append(distance_L[j, j+outer_window, 1])

  times.append(time) 

phti0 = np.array(phti0)
phti1 = np.array(phti1)

phti0 = np.array(phti0)
phti1 = np.array(phti1)

# using outer_window of 5
plt.figure(figsize=(20,6))

plt.subplot(1,2,1)
plt.plot(times, phti0)
plt.axvline(x=times[203], linewidth=2, color='#ff7f0e', linestyle='--')
plt.axvline(x=times[216], linewidth=2, color='red', linestyle='--')
plt.axvline(x=times[218], linewidth=2, color='#ff7f0e', linestyle='--')
plt.tick_params(axis='x', rotation=70)
plt.title("Index based on homology dimension 0")

plt.subplot(1,2,2)
plt.plot(times, sp500['Close'][times])
plt.axvline(x=times[203], linewidth=2, color='#ff7f0e', linestyle='--')
plt.axvline(x=times[216], linewidth=2, color='red', linestyle='--')
plt.axvline(x=times[218], linewidth=2, color='#ff7f0e', linestyle='--')
plt.tick_params(axis='x', rotation=70)
plt.title("Close prices of the SP500")

plt.savefig("SP500")

plt.figure(figsize=(10,8))
plt.plot(times, phti1)
plt.axvline(x=times[216], linewidth=2, color='red', linestyle='--')
plt.tick_params(axis='x', rotation=70)
plt.title("Index based on homology dimension 1")

print(times[:2])
print(times[-2:])

times.index(pd.Timestamp('2020-02-20'))

times[150]

print(phti0[189:216].max())
print(list(phti0).index(phti0[189:216].max()))

antiguo_maximo = phti0[189:216].max()

for i in range(189, len(times), 1):
  if phti0[i] > antiguo_maximo:
    time_signal = i
    break
    
print(phti0[time_signal])
print(times[time_signal])
print(time_signal)

"""###Comparison with PHTI (Baitinger and Flegel)"""

start_date = '2019-01-01'
end_date = '2020-12-31'

industry_portfolio = pd.read_csv("https://raw.githubusercontent.com/miguelruor/TDA_financial_markets/main/10_Industry_Portfolios_Daily.csv")
industry_portfolio = industry_portfolio.rename(columns={"Unnamed: 0": "Date"})
industry_portfolio = industry_portfolio.astype({'Date': 'string'})
industry_portfolio['Date'] = industry_portfolio['Date'].apply(lambda date: date[:4]+"-"+date[4:6]+"-"+date[6:])
industry_portfolio = industry_portfolio[(industry_portfolio['Date'] > start_date) & (industry_portfolio['Date'] <= end_date)].reset_index(drop=True)
industry_portfolio['Date'] = industry_portfolio['Date'].apply(pd.Timestamp)
industry_portfolio.set_index("Date", inplace=True)

industry_portfolio

point_cloud = industry_portfolio.to_numpy()

point_cloud

window_size = 60
window_stride = 1

sliding_window = ts.SlidingWindow(size=window_size, stride=window_stride)

point_cloud_windows = sliding_window.fit_transform(point_cloud)

point_cloud_windows[:5,:5,:5]

print(f'Number of windows: {point_cloud_windows.shape[0]}')
print(f'Window size: {point_cloud_windows.shape[1]}')
print(f'Embedding dimension: {point_cloud_windows.shape[2]}')
point_cloud_windows.shape

homology_dimensions = (0, 1) # homology dimensions of interest
VR = hl.VietorisRipsPersistence(homology_dimensions=homology_dimensions, n_jobs=-1) # Vietoris Rips persistence diagrams
diagrams = VR.fit_transform(point_cloud_windows)

p = 2
PD = diag.PairwiseDistance(metric='wasserstein', order=None, n_jobs=-1)
distance_L = PD.fit_transform(diagrams)
distance_L.shape

time_index = industry_portfolio.index[59:]

print(len(time_index))
print(point_cloud_windows.shape)

outer_window = 1

phti0 = []
phti1 = []
times = time_index[outer_window:]

for j, time in enumerate(time_index[outer_window:]):

  phti0.append(distance_L[j, j+outer_window, 0])
  phti1.append(distance_L[j, j+outer_window, 1])

phti0 = np.array(phti0)
phti1 = np.array(phti1)

phti0[:10].sum()

def moving_average(window, array):
  ma = []
  for i in range(len(array)-window+1):
    sum = array[i:(i+window)].sum()
    ma.append(sum/window)
  
  return np.array(ma)

phti0_ma = moving_average(60, phti0)
phti1_ma = moving_average(60, phti1)

print(len(phti0_ma))
print(len(phti0))
print(len(times))
times = times[59:]
print(len(times))

maximo = phti0[210]
index_max = 210

for i in range(210,225):
  if phti0[i] > maximo:
    maximo = phti0[i]
    index_max = i

print(maximo, index_max, times[index_max])

maximo2 = phti0[225]
index_max2 = 225

for i in range(225,231):
  if phti0[i] > maximo2:
    maximo2 = phti0[i]
    index_max2 = i

print(maximo2, index_max2, times[index_max2])

print(times[166])

times

# using outer_window of 5
plt.figure(figsize=(20,6))

plt.subplot(1,2,1)
plt.plot(times, phti0_ma)
plt.axvline(x=times[70], linewidth=2, color='#ff7f0e', linestyle='--')
plt.axvline(x=times[166], linewidth=2, color='red', linestyle='--')
plt.axvline(x=times[170], linewidth=2, color='#ff7f0e', linestyle='--')
plt.tick_params(axis='x', rotation=70)
plt.title("Baitinger and Flegel (2019) index based on homology dimension 0")

maximo = phti0_ma[0]
index_max = 0

for i in range(111):
  if phti0_ma[i] > maximo:
    maximo = phti0_ma[i]
    index_max = i

print(maximo, index_max, times[index_max])

maximo2 = phti0_ma[150]
index_max2 = 150

for i in range(150,189):
  if phti0_ma[i] > maximo:
    maximo2 = phti0_ma[i]
    index_max2 = i
    break

print(maximo2, index_max2, times[index_max2])

plt.figure(figsize=(10,8))
plt.plot(times, phti1_ma)
#plt.axvline(x=times[225], linewidth=2, color='red', linestyle='--')
plt.tick_params(axis='x', rotation=70)
plt.title("Index based on homology dimension 1")

